#' @title In convex hull
#' 
#' @description  Given a \eqn{d}-dimensional 
#' \href{https://en.wikipedia.org/wiki/Convex_hull}{convex hull} this function 
#' checks to see which of a set of \eqn{n} test points are within the convex 
#' hull.  This function uses the \href{http://www.qhull.org}{Qhull} library.
#' 
#' @param hull A convex hull list object created by \code{\link{convex_hull}}
#' @param test_points a \eqn{n}-by-\eqn{d} dataframe or matrix. The rows
#'   represent \eqn{n} points and the \eqn{d} columns the coordinates in 
#'   \eqn{d}-dimensional space.
#' 
#' @return A \eqn{n} length vector containing \code{TRUE} if test point \eqn{n} 
#' lies within the hull and \code{FALSE} if it lies outside the hull.
#' 
#' @seealso \code{\link{convex_hull}}
#' 
#' @references Barber CB, Dobkin DP, Huhdanpaa H (1996) The Quickhull algorithm 
#' for convex hulls. ACM Transactions on Mathematical Software, 22(4):469-83 
#' \url{https://doi.org/10.1145/235815.235821}.
#' 
#' @examples 
#' # Define points to create the convex hull
#' x <- c(30, 70, 20, 50, 40, 70)
#' y <- c(35, 80, 70, 50, 60, 20)
#' p <- data.frame(x, y)
#' ch <- convex_hull(points = p)
#' plot(p, pch = as.character(seq(nrow(p))), xlim=c(0,100), ylim=c(0,100))
#' for (s in seq(nrow(ch$hull_simplices))) {
#'   lines(ch$input_points[ch$hull_simplices[s, ], ], col = "red")
#' }
#' # Check if some test points are in the convex hull
#' p_test <- data.frame(c(20, 50, 60, 90), c(20, 60, 60, 40))
#' points(p_test[,1], p_test[,2], pch=c("1", "2", "3", "4"), col="blue")
#' legend("topright", legend = c("input points", "test points"), 
#'        text.col=c("black", "blue"), title = "Indices for:", bty="n")
#' p_test_hull <- in_convex_hull(hull = ch, test_points = p_test)
#' print(p_test_hull)
#' 
#' @export in_convex_hull
  in_convex_hull <- function(hull=NULL, test_points=NULL) {
  
    # Check directory writable
  	tmpdir <- tempdir()
  	# R should guarantee the tmpdir is writable, but check in any case
  	if (file.access(tmpdir, 2) == -1) {
  		stop(paste("Unable to write to R temporary directory", tmpdir, "\n"))
  	}
  	
  	# Coerce the input to be matrix
  	if(is.null(test_points)){
  		stop(paste("test_points must be an n-by-d dataframe or matrix", "\n"))
  	}
  	if(!is.data.frame(test_points) & !is.matrix(test_points)){
  	  stop(paste("test_points must be a dataframe or matrix", "\n"))
  	}
  	if (is.data.frame(test_points)) {
  	  test_points <- as.matrix(test_points)
  	}
  	# Make sure we have real-valued input
  	storage.mode(test_points) <- "double"
  	
  	# Check convex hull
  	if(is.null(hull)){
  		stop(paste("hull must be convex hull generated by convex_hull", "\n"))
  	}  	
	  # Extract the convex hull points from the convex hull object
    points <- hull$hull_vertices
    # Make sure we have real-valued input
    storage.mode(points) <- "double"
    
    # Check that the test points have the same dimensions as the convex hull
    # TO DO!
    
    # Specify the Qhull options: http://www.qhull.org/html/qh-optq.htm
    options <- "Qt"
    
    # Call C function to create the convex hull
    convex <- .Call("C_convex", points, options, tmpdir, PACKAGE="compGeometeR")
    
    # Call C function to check if points are inside the convex hull
    return(.Call("C_inconvexhull", convex$convex_hull, test_points, PACKAGE="compGeometeR"))
    
  }